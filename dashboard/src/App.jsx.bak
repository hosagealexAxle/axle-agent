import { useEffect, useMemo, useRef, useState } from "react";

const API_BASE = "http://localhost:4000";

// ---------- localStorage helpers ----------
const LS = {
  threads: "axle.threads.v1",
  activeThread: "axle.activeThread.v1",
  msgs: (id) => `axle.messages.v1.${id}`,
};

function safeJsonParse(s, fallback) {
  try {
    return JSON.parse(s);
  } catch {
    return fallback;
  }
}

function loadThreads() {
  const raw = localStorage.getItem(LS.threads);
  const t = safeJsonParse(raw, null);
  if (Array.isArray(t) && t.length) return t;
  // default thread
  return [{ id: "default", title: "Axle (Local)" }];
}

function saveThreads(threads) {
  localStorage.setItem(LS.threads, JSON.stringify(threads));
}

function loadActiveThreadId() {
  return localStorage.getItem(LS.activeThread) || "default";
}

function saveActiveThreadId(id) {
  localStorage.setItem(LS.activeThread, id);
}

function loadMessages(threadId) {
  const raw = localStorage.getItem(LS.msgs(threadId));
  const m = safeJsonParse(raw, null);
  if (Array.isArray(m)) return m;
  return [];
}

function saveMessages(threadId, messages) {
  localStorage.setItem(LS.msgs(threadId), JSON.stringify(messages));
}

function nowTs() {
  return Date.now();
}

function formatTime(ts) {
  try {
    return new Date(ts).toLocaleString();
  } catch {
    return "";
  }
}

// ---------- App ----------
export default function App() {
  const [backendOk, setBackendOk] = useState(false);
  const [policy, setPolicy] = useState(null);

  const [threads, setThreads] = useState(() => loadThreads());
  const [activeThreadId, setActiveThreadId] = useState(() =>
    loadActiveThreadId()
  );

  const [messages, setMessages] = useState(() => loadMessages(loadActiveThreadId()));
  const [input, setInput] = useState("");
  const [busy, setBusy] = useState(false);

  const [mode, setMode] = useState("chat");
  const [lastActions, setLastActions] = useState([]);

  const chatRef = useRef(null);

  const activeThread = useMemo(
    () => threads.find((t) => t.id === activeThreadId) || threads[0],
    [threads, activeThreadId]
  );

  // Ensure active thread exists (if localStorage got weird)
  useEffect(() => {
    if (!threads.some((t) => t.id === activeThreadId)) {
      const fallback = threads[0]?.id || "default";
      setActiveThreadId(fallback);
      saveActiveThreadId(fallback);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Persist threads whenever they change
  useEffect(() => {
    saveThreads(threads);
  }, [threads]);

  // When active thread changes, load its messages and persist active id
  useEffect(() => {
    saveActiveThreadId(activeThreadId);
    const m = loadMessages(activeThreadId);
    setMessages(m);
  }, [activeThreadId]);

  // Auto scroll on new messages
  useEffect(() => {
    if (!chatRef.current) return;
    chatRef.current.scrollTop = chatRef.current.scrollHeight;
  }, [messages, busy]);

  async function refreshHealth() {
    try {
      const r = await fetch(`${API_BASE}/api/health`);
      const j = await r.json();
      setBackendOk(!!j?.ok);
    } catch {
      setBackendOk(false);
    }
  }

  async function refreshPolicy() {
    try {
      const r = await fetch(`${API_BASE}/api/policy`);
      const j = await r.json();
      setPolicy(j);
    } catch {
      setPolicy(null);
    }
  }

  useEffect(() => {
    refreshHealth();
    refreshPolicy();
    const t = setInterval(() => {
      refreshHealth();
    }, 5000);
    return () => clearInterval(t);
  }, []);

  function newChat() {
    const id = `t_${Math.random().toString(36).slice(2, 10)}`;
    const title = `Chat ${threads.length + 1}`;
    const next = [{ id, title }, ...threads];
    setThreads(next);
    setActiveThreadId(id);

    // starter message
    const starter = [
      {
        role: "assistant",
        content:
          "Hey — I’m Axle. Etsy API is pending, so I’m running in planning + safety mode.\n\nTry:\n• “Plan my SEO today”\n• “/budget”\n• “toggle ads”",
        ts: nowTs(),
      },
    ];
    setMessages(starter);
    saveMessages(id, starter);
  }

  async function send(textOverride) {
    const text = (textOverride ?? input).trim();
    if (!text || busy) return;

    setBusy(true);
    setInput("");

    const userMsg = { role: "user", content: text, ts: nowTs() };
    const optimistic = [...messages, userMsg];
    setMessages(optimistic);
    saveMessages(activeThreadId, optimistic);

    try {
      const r = await fetch(`${API_BASE}/api/chat`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ threadId: activeThreadId, message: text }),
      });

      // If server returns HTML, this will throw, and we show a clean error.
      const j = await r.json();
      if (!j?.ok) throw new Error(j?.error || "chat failed");

      const assistantMsg = {
        role: "assistant",
        content: String(j.reply ?? ""),
        ts: nowTs(),
      };

      const next = [...optimistic, assistantMsg];
      setMessages(next);
      saveMessages(activeThreadId, next);

      setMode(j.mode || "chat");
      setLastActions(Array.isArray(j.actions) ? j.actions : []);
    } catch (e) {
      const errMsg = {
        role: "assistant",
        content: `⚠️ Error: ${e?.message || "Failed to fetch"}`,
        ts: nowTs(),
      };
      const next = [...optimistic, errMsg];
      setMessages(next);
      saveMessages(activeThreadId, next);
    } finally {
      setBusy(false);
    }
  }

  function onQuick(cmd) {
    send(cmd);
  }

  return (
    <div className="app">
      {/* LEFT */}
      <div className="left">
        <div className="panel">
          <div className="title">Axle</div>
          <div className="small">Local operator console • Etsy API pending</div>
          <button className="button" onClick={newChat} style={{ marginTop: 12 }}>
            + New chat
          </button>
        </div>

        <div className="panel" style={{ flex: 1 }}>
          {threads.map((t) => (
            <div
              key={t.id}
              className={"thread " + (t.id === activeThreadId ? "active" : "")}
              onClick={() => setActiveThreadId(t.id)}
              role="button"
              tabIndex={0}
            >
              <div style={{ fontWeight: 800 }}>{t.title}</div>
              <div className="small">id: {t.id}</div>
            </div>
          ))}
        </div>

        <div className="small" style={{ padding: "8px 14px" }}>
          Backend: {backendOk ? "✅ Online" : "❌ Offline"}
          <br />
          API: {API_BASE}
        </div>
      </div>

      {/* MID */}
      <div className="mid">
        <div className="panel" style={{ display: "flex", alignItems: "center", justifyContent: "space-between" }}>
          <div className="title">{activeThread?.title || "Axle (Local)"}</div>
          <div className="small">Mode: <strong style={{ color: "var(--text)" }}>{mode}</strong></div>
        </div>

        <div className="chat" ref={chatRef}>
          {messages.map((m, idx) => (
            <div
              key={idx}
              className={
                "msg " + (m.role === "user" ? "msgUser" : "msgAssistant")
              }
            >
              <div style={{ whiteSpace: "pre-wrap" }}>{m.content}</div>
              <div className="small" style={{ marginTop: 6 }}>
                {m.role} • {formatTime(m.ts)}
              </div>
            </div>
          ))}
          {busy && (
            <div className="msg msgAssistant">
              <div>…thinking</div>
            </div>
          )}
        </div>

        <div className="composer">
          <input
            className="input"
            value={input}
            placeholder="Message Axle… (Shift+Enter for new line)"
            onChange={(e) => setInput(e.target.value)}
            onKeyDown={(e) => {
              if (e.key === "Enter" && !e.shiftKey) {
                e.preventDefault();
                send();
              }
            }}
          />
          <button className="button" onClick={() => send()}>
            Send
          </button>
        </div>
      </div>

      {/* RIGHT */}
      <div className="rightcol">
        <div className="panel">
          <div className="title">System</div>
          <div className="kv">
            <span>Backend</span>
            <strong>{backendOk ? "Online" : "Offline"}</strong>
          </div>
          <div className="kv">
            <span>Thread</span>
            <strong>{activeThreadId}</strong>
          </div>
          <div className="kv">
            <span>Mode</span>
            <strong>{mode}</strong>
          </div>
        </div>

        <div className="panel">
          <div className="sectionTitle">Actions (last)</div>
          <div className="code">{JSON.stringify(lastActions, null, 2)}</div>
        </div>

        <div className="panel">
          <div className="sectionTitle">Quick commands</div>
          <button className="button" onClick={() => onQuick("/budget")}>
            /budget
          </button>
          <button className="button" onClick={() => onQuick("toggle ads")}>
            toggle ads
          </button>
          <button className="button" onClick={() => onQuick("kill switch on")}>
            kill switch on
          </button>
          <button className="button" onClick={() => onQuick("Plan my SEO today")}>
            Plan my SEO today
          </button>
        </div>

        <div className="small" style={{ opacity: 0.8 }}>
          Next: persistent backend memory + Etsy API actions (when approved).
        </div>

        {policy && (
          <div className="panel">
            <div className="sectionTitle">Policy</div>
            <div className="code">{JSON.stringify(policy, null, 2)}</div>
          </div>
        )}
      </div>
    </div>
  );
}
